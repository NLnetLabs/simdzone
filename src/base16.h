/*
 * base16.h -- parser for base16 rdata in (DNS) zone files
 *
 * Copyright (c) 2022, NLnet Labs. All rights reserved.
 *
 * See LICENSE for the license.
 */
#ifndef ZONE_BASE16_H
#define ZONE_BASE16_H

static inline zone_return_t accept_base16(
  zone_parser_t *par, zone_field_t *fld, void *ptr)
{
  if (par->parser.base16.state != 0)
    SEMANTIC_ERROR(par, "Invalid base16 sequence");

  uint8_t *octs;
  if (!(octs = zone_malloc(par, par->parser.base16.length)))
    return ZONE_OUT_OF_MEMORY;
  memcpy(octs, par->parser.base16.octets, par->parser.base16.length);
  fld->binary.length = par->parser.base16.length;
  fld->binary.octets = octs;

  zone_return_t ret;
  if ((ret = par->options.accept.rdata(par, fld, ptr)) < 0)
    zone_free(par, octs);
  par->parser.base16.length = 0;
  par->parser.base16.state = 0;
  // FIXME: improve, quick hack
  par->parser.wks.protocol = NULL;
  return 0;
}

static const uint8_t b16rmap[256] = {
  0xfd, 0xff, 0xff, 0xff,  0xff, 0xff, 0xff, 0xff,  /*   0 -   7 */
  0xff, 0xfe, 0xfe, 0xfe,  0xfe, 0xfe, 0xff, 0xff,  /*   8 -  15 */
  0xff, 0xff, 0xff, 0xff,  0xff, 0xff, 0xff, 0xff,  /*  16 -  23 */
  0xff, 0xff, 0xff, 0xff,  0xff, 0xff, 0xff, 0xff,  /*  24 -  31 */
  0xfe, 0xff, 0xff, 0xff,  0xff, 0xff, 0xff, 0xff,  /*  32 -  39 */
  0xff, 0xff, 0xff, 0x3e,  0xff, 0xff, 0xff, 0x3f,  /*  40 -  47 */
  0x00, 0x01, 0x02, 0x03,  0x04, 0x05, 0x06, 0x07,  /*  48 -  55 */
  0x08, 0x09, 0xff, 0xff,  0xff, 0xff, 0xff, 0xff,  /*  56 -  63 */
  0xff, 0x0a, 0x0b, 0x0c,  0x0d, 0x0e, 0x0f, 0xff,  /*  64 -  71 */
  0xff, 0xff, 0xff, 0xff,  0xff, 0xff, 0xff, 0xff,  /*  72 -  79 */
  0xff, 0xff, 0xff, 0xff,  0xff, 0xff, 0xff, 0xff,  /*  80 -  87 */
  0xff, 0xff, 0xff, 0xff,  0xff, 0xff, 0xff, 0xff,  /*  88 -  95 */
  0xff, 0x0a, 0x0b, 0x0c,  0x0d, 0x0e, 0x0f, 0xff,  /*  96 - 103 */
  0xff, 0xff, 0xff, 0xff,  0xff, 0xff, 0xff, 0xff,  /* 104 - 111 */
  0xff, 0xff, 0xff, 0xff,  0xff, 0xff, 0xff, 0xff,  /* 112 - 119 */
  0xff, 0xff, 0xff, 0xff,  0xff, 0xff, 0xff, 0xff,  /* 120 - 127 */
  0xff, 0xff, 0xff, 0xff,  0xff, 0xff, 0xff, 0xff,  /* 128 - 135 */
  0xff, 0xff, 0xff, 0xff,  0xff, 0xff, 0xff, 0xff,  /* 136 - 143 */
  0xff, 0xff, 0xff, 0xff,  0xff, 0xff, 0xff, 0xff,  /* 144 - 151 */
  0xff, 0xff, 0xff, 0xff,  0xff, 0xff, 0xff, 0xff,  /* 152 - 159 */
  0xff, 0xff, 0xff, 0xff,  0xff, 0xff, 0xff, 0xff,  /* 160 - 167 */
  0xff, 0xff, 0xff, 0xff,  0xff, 0xff, 0xff, 0xff,  /* 168 - 175 */
  0xff, 0xff, 0xff, 0xff,  0xff, 0xff, 0xff, 0xff,  /* 176 - 183 */
  0xff, 0xff, 0xff, 0xff,  0xff, 0xff, 0xff, 0xff,  /* 184 - 191 */
  0xff, 0xff, 0xff, 0xff,  0xff, 0xff, 0xff, 0xff,  /* 192 - 199 */
  0xff, 0xff, 0xff, 0xff,  0xff, 0xff, 0xff, 0xff,  /* 200 - 207 */
  0xff, 0xff, 0xff, 0xff,  0xff, 0xff, 0xff, 0xff,  /* 208 - 215 */
  0xff, 0xff, 0xff, 0xff,  0xff, 0xff, 0xff, 0xff,  /* 216 - 223 */
  0xff, 0xff, 0xff, 0xff,  0xff, 0xff, 0xff, 0xff,  /* 224 - 231 */
  0xff, 0xff, 0xff, 0xff,  0xff, 0xff, 0xff, 0xff,  /* 232 - 239 */
  0xff, 0xff, 0xff, 0xff,  0xff, 0xff, 0xff, 0xff,  /* 240 - 247 */
  0xff, 0xff, 0xff, 0xff,  0xff, 0xff, 0xff, 0xff,  /* 248 - 255 */
};

static const uint8_t b16rmap_special = 0xf0;
static const uint8_t b16rmap_end = 0xfd;
static const uint8_t b16rmap_space = 0xfe;

static inline zone_return_t parse_base16(
  zone_parser_t *par, const zone_token_t *tok, zone_field_t *fld, void *ptr)
{
  size_t cur = 0;
  zone_char_t ch;
  uint8_t ofs;

  (void)fld;
  (void)ptr;

  for (;;) {
    if ((ch = zone_string_next(&tok->string, &cur, 0)) < 0)
      SEMANTIC_ERROR(par, "Invalid escape sequence");
    ofs = b16rmap[(uint8_t)ch & 0xff];

    if (ofs >= b16rmap_special) {
      // Ignore whitespaces
      if (ofs == b16rmap_space)
        continue;
      // End of base64 characters
      if (ofs == b16rmap_end)
        break;
      SEMANTIC_ERROR(par, "Invalid character in base16 encoding");
    }

    if (par->parser.base16.state == 0) {
      par->parser.base16.octets[par->parser.base16.length]  = ofs << 4;
      par->parser.base16.state = 1;
    } else if (par->parser.base16.state == 1) {
      par->parser.base16.octets[par->parser.base16.length] |= ofs;
      par->parser.base16.state = 0;
      if (par->parser.base16.length == UINT16_MAX - 1)
        SEMANTIC_ERROR(par, "Base16 sequence is too big");
      par->parser.base16.length++;
    }
  }

  assert(ch == '\0');
  return ZONE_DEFER_ACCEPT;
}

#endif // ZONE_BASE16_H
